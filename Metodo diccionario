def compressionDiccionario(input_string):
    dictionary = {}  # Inicializamos el diccionario vacío
    encoded_text = []  # Lista para almacenar el texto codificado

    for char in input_string:
        if char in dictionary:
            # Si el carácter está en el diccionario, agregamos su índice al texto codificado
            encoded_text.append(f"({dictionary[char]}, 1)")
        else:
            # Si no está en el diccionario, lo agregamos y emitimos el carácter sin modificar
            index = len(dictionary)
            dictionary[char] = index
            encoded_text.append(f"({index}, 1)")

    # Convertimos la lista de texto codificado en una cadena
    encoded_string = " ".join(encoded_text)
    return encoded_string, dictionary

# Ejemplo de uso
input_string = "abracadabra abracadabra abracadabra"
encoded_result, initial_dictionary = compression_by_dictionary(input_string)
print(f"Texto codificado: {encoded_result}")
print(f"Diccionario inicial: {initial_dictionary}")

#  OPCION 1 Requerimiento 7 

import os
from PIL import Image
def descomprimir_rle(archivo_codificado):
  """
  Función que descomprime una imagen codificada con RLE y la convierte en una imagen PIL.

  Args:
    archivo_codificado: Ruta del archivo codificado con RLE.

  Returns:
    Image: Imagen PIL descomprimida.
  """
  # Obtener nombre y extensión del archivo original
  nombre, extension = os.path.splitext(archivo_codificado)

  # Leer el archivo codificado
  with open(archivo_codificado, 'r') as f:
    datos = f.read().strip()

  # Inicializar variables para descompresión
  imagen = []
  color_actual = None
  repeticiones = 0

  # Recorrer los datos codificados
  for dato in datos.split():
    if dato.isdigit():
      # Si es un número, indica la cantidad de repeticiones
      repeticiones = int(dato)
    else:
      # Si no es un número, indica el color del pixel
      color = tuple(int(valor) for valor in dato.split(','))
      if color_actual:
        # Agregar repeticiones del color anterior a la imagen
        imagen.extend([color_actual] * repeticiones)
      color_actual = color
      repeticiones = 1

  # Si queda un color pendiente, agregarlo a la imagen
  if color_actual:
    imagen.extend([color_actual] * repeticiones)

  # Convertir la lista de colores en una imagen PIL
  imagen = Image.fromarray(numpy.array(imagen).reshape((imagen[0], imagen[1], 3)))

  # Guardar la imagen descomprimida con la extensión original
  imagen.save(nombre + extension)

  # Devolver la imagen PIL descomprimida
  return imagen

archivo_codificado = "imagen_codificada.rle"  # Ruta del archivo codificado
imagen_descomprimida = descomprimir_rle(archivo_codificado)

# Mostrar la imagen descomprimida
imagen_descomprimida.show()

# OPCION 2 RQUERIMIENTO 7

def decode_rle(encoded_data):
    decoded_data = bytearray()  # Se crea un objeto bytearray vacío para almacenar los datos decodificados.
    i = 0  # Se inicializa el índice para iterar sobre los datos codificados.
    while i < len(encoded_data):  # Se inicia un bucle while para iterar sobre los datos codificados.
        run_length = encoded_data[i]  # Se obtiene la longitud de la corrida (número de repeticiones) del valor del píxel.
        pixel_value = encoded_data[i+1]  # Se obtiene el valor del píxel.
        decoded_data.extend([pixel_value] * run_length)  # Se agrega el valor del píxel repetido según la longitud de la corrida al objeto bytearray decodificado.
        i += 2  # Se incrementa el índice en 2 para saltar al siguiente par de longitud de corrida y valor del píxel.
    return decoded_data  # Se devuelve el objeto bytearray decodificado.

def save_image(data, width, height, output_file):
    from PIL import Image  # Se importa la clase Image de la biblioteca PIL.
    img = Image.frombytes('L', (width, height), bytes(data))  # Se crea una imagen a partir de los datos decodificados utilizando la clase Image.
    img.save(output_file)  # Se guarda la imagen en un archivo de salida especificado.

def decompress_rle(input_file, output_file):
    with open(input_file, 'rb') as f:  # Se abre el archivo codificado en modo de lectura binaria.
        encoded_data = bytearray(f.read())  # Se lee todo el contenido del archivo codificado y se almacena en un objeto bytearray.

    decoded_data = decode_rle(encoded_data)  # Se decodifica los datos RLE.

    width = decoded_data[0] * 256 + decoded_data[1]  # Se calcula el ancho de la imagen a partir de los primeros dos bytes de los datos decodificados.
    height = decoded_data[2] * 256 + decoded_data[3]  # Se calcula la altura de la imagen a partir de los siguientes dos bytes de los datos decodificados.

    save_image(decoded_data[4:], width, height, output_file)  # Se guarda la imagen restaurada, ignorando los primeros 4 bytes que representan el ancho y la altura.

# Ejemplo de uso
input_file = 'imagen_codificada.rle'  # Se especifica el archivo codificado.
output_file = 'imagen_restaurada.png'  # Se especifica el nombre del archivo de salida.

decompress_rle(input_file, output_file)  # Se llama a la función decompress_rle para descomprimir el archivo y guardar la imagen restaurada.





